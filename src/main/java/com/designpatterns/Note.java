package com.designpatterns;

/**
 * @author: jiangjiabin
 * @date: Create in 0:40 2021/3/25
 * @description: note
 */
public class Note {

    /**
     *
     * todo uml 类图   每一个设计原则的 UMl 建模图
     *
     * 六大原则：
     * 1、单一职责：一个类只负责一个职责
     *      注意事项和细节——
     *          (1)降低类的复杂度，一个类只负责一项职责
     *          (2)提高类的可读性和可维护性
     *          (3)降低变更引起的风险
     *          (4)可以在方法级别保证单一职责原则
     * 2、开闭原则：
     *
     * 3、里氏替换原则
     *
     * 4、依赖倒转原则
     *
     * 5、接口隔离原则：客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应建立在最小接口上
     *
     * 6、迪米特法则
     *
     * 合成复用原则
     *
     * todo 补充详细内容
     *
     */

    /**
     * 创建型：
     *      常用：工厂、抽象工厂、单例、建造者
     *      不cy：原型模式
     * 结构型：
     *      常用：适配器、桥接、装饰器、代理
     *      不cy：组合、外观、享元
     * 行为型：
     *      常用：责任链、迭代、观察者、状态、策略、模板
     *      不cy：备忘录、命令
     *      几乎不用：访问者、中介、解释器
     *
     *
     *
     * #单例：
     *      适用场景：业务系统全局只需要一个对象实例，比如redis连接对象
     *      spring 容器中bean默认是单例
     *
     *      分类：
     *          懒汉、饿汉  todo ...
     *
     *      实现步骤：
     *          ->私有化构造方法
     *          ->提供获取单例的方法
     *
     *      懒汉和饿汉的优缺点  todo
     *
     *      JDK 源码的单例：
     *          {@link Runtime} 为什么用饿汉 ？ todo
     *
     *
     * #工厂
     *  $简单工厂
     *  $工厂方法
     *  $抽象工厂
     *
     *  简单工厂：
     *      应用场景：
     *          解耦——分离职责，把复杂对象的创建和使用分开
     *          复用代码，降低维护成本
     *      优点：将对象的创建和本身业务处理分离，可以降低系统的耦合度
     *      缺点：(1)工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点违背了开闭原则；
     *            (2)会增加系统中类的个数，在一定程度上增加了系统的复杂度和理解难度，不利于系统的维护和扩展。
     *
     *  工厂方法模式：
     *      是对简单工厂的进一步抽象，满足开闭原则；
     *      将类的实例化延迟到工厂类的子类中完成。
     *
     *      核心组成：
     *          1）抽象产品类 IProduct
     *          2）具体产品类 Product
     *
     *          3）抽象工厂类 IFactory
     *          4）具体工厂类 Factory
     *
     *      优点：
     *          符合开闭原则，增加一个产品，只需要实现其他具体的产品类和具体的工厂类；
     *          符合单一职责原则，每个工厂只负责生产对应的产品；
     *          使用者只需要知道产品的抽象类，无需关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则
     *      缺点：
     *          增加一个产品，需要实现具体的工厂类和具体产品类；
     *          每个产品需要有对应的具体工厂类和具体产品类
     *
     * 抽象工厂模式：
     *      是工厂方法模式的升级版，当需要创建的产品有多个产品线时使用抽象工厂是比较好的选择
     *
     *      优点：
     *          当一个产品族中的多个对象被设计成一起工作时，他能保证使用方始终只使用同一个产品族中的对象
     *      缺点：
     *          产品族扩展困难，要增加一个系列的某一个产品，既要在抽象的工厂和抽象的产品里修改代码，又要在
     *          具体的产品里面增加代码，不是很符合开闭原则。
     *          增加了系统的抽象性和理解难度。
     *
     */
}
