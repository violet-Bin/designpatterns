package com.designpatterns;

/**
 * @author: jiangjiabin
 * @date: Create in 0:40 2021/3/25
 * @description: note
 */
public class Note {

    /**
     *
     * 六大原则：
     * 1、单一职责：一个类只负责一个职责
     *      注意事项和细节——
     *          (1)降低类的复杂度，一个类只负责一项职责
     *          (2)提高类的可读性和可维护性
     *          (3)降低变更引起的风险
     *          (4)可以在方法级别保证单一职责原则
     * 2、开闭原则：
     *      （1）一个软件实体，模块和函数应该对扩展开放，对修改关闭，用抽象构建框架，用实现扩展细节；
     *      （2）当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有代码来实现变化；
     *      （3）编程中遵循其他原则，以及使用设计模式的目的就是为了遵循开闭原则；
     *
     * 3、里氏替换原则：
     *      （1）所有引用基类的地方必须能透明的使用使用其子类对象；
     *      （2）子类尽量不要重写父类的方法；
     *      （3）继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合、组合、依赖来解决问题；
     *      （4）为了避免无意重写父类方法导致的错误，可以让原来的父类和子类都继承一个更通俗的基类（比如没有方法的基类），
     *          原有的继承关系去掉，采用聚合、组合、依赖关系代替；
    *
     * 4、依赖倒转原则：
     *      （1）高层模块不应该依赖底层模块，二者都因该依赖其抽象；
     *      （2）抽象不应该依赖细节，细节应该依赖抽象；
     *      （3）依赖倒转的中心思想是面向接口编程；
     *
     * 5、接口隔离原则：客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应建立在最小接口上
     *
     * 6、迪米特法则：
     *      （1）一个对象应该对其他对象保持最少的了解；
     *      （2）类与类关系越密切，耦合度越大；
     *      （3）迪米特法则又叫 最少知道原则，及一个类对自己依赖的类知道的越少越好；
     *      （4）只与直接朋友通信；（直接朋友：出现在 成员变量、方法参数、方法返回值中的类）
     *
     * 合成复用原则：
     *      尽量使用合成、聚合的方式，而不是使用继承
     *
     * 设计原则核心思想：
     *      （1）找出应用中可能变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起；
     *      （2）针对接口编程，而不是针对实现编程；
     *      （3）为了交互对象之间的松耦合而努力。
     *
     */

    /**
     * 创建型：
     *      常用：工厂、抽象工厂、单例、建造者
     *      不cy：原型模式
     * 结构型：
     *      常用：适配器、桥接、装饰器、代理
     *      不cy：组合、外观、享元
     * 行为型：
     *      常用：责任链、迭代、观察者、状态、策略、模板
     *      不cy：备忘录、命令
     *      几乎不用：访问者、中介、解释器
     *
     *
     *
     * #单例：
     *      适用场景：业务系统全局只需要一个对象实例，比如redis连接对象
     *      spring 容器中bean默认是单例
     *
     *      分类：
     *          懒汉、饿汉  todo ...
     *
     *      实现步骤：
     *          ->私有化构造方法
     *          ->提供获取单例的方法
     *
     *      懒汉和饿汉的优缺点  todo
     *
     *      JDK 源码的单例：
     *          {@link Runtime} 为什么用饿汉 ？ todo
     *
     *
     * #工厂
     *  $简单工厂
     *  $工厂方法
     *  $抽象工厂
     *
     *  简单工厂：
     *      应用场景：
     *          解耦——分离职责，把复杂对象的创建和使用分开
     *          复用代码，降低维护成本
     *      优点：将对象的创建和本身业务处理分离，可以降低系统的耦合度
     *      缺点：(1)工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点违背了开闭原则；
     *            (2)会增加系统中类的个数，在一定程度上增加了系统的复杂度和理解难度，不利于系统的维护和扩展。
     *
     *  工厂方法模式：
     *      是对简单工厂的进一步抽象，满足开闭原则；
     *      将类的实例化延迟到工厂类的子类中完成。
     *
     *      核心组成：
     *          1）抽象产品类 IProduct
     *          2）具体产品类 Product
     *
     *          3）抽象工厂类 IFactory
     *          4）具体工厂类 Factory
     *
     *      优点：
     *          符合开闭原则，增加一个产品，只需要实现其他具体的产品类和具体的工厂类；
     *          符合单一职责原则，每个工厂只负责生产对应的产品；
     *          使用者只需要知道产品的抽象类，无需关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则
     *      缺点：
     *          增加一个产品，需要实现具体的工厂类和具体产品类；
     *          每个产品需要有对应的具体工厂类和具体产品类
     *
     * 抽象工厂模式：
     *      是工厂方法模式的升级版，当需要创建的产品有多个产品线时使用抽象工厂是比较好的选择
     *
     *      优点：
     *          当一个产品族中的多个对象被设计成一起工作时，他能保证使用方始终只使用同一个产品族中的对象
     *      缺点：
     *          产品族扩展困难，要增加一个系列的某一个产品，既要在抽象的工厂和抽象的产品里修改代码，又要在
     *          具体的产品里面增加代码，不是很符合开闭原则。
     *          增加了系统的抽象性和理解难度。
     *
     */
}
